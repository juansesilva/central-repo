name: Generate Release Notes

on:
  # Triggered by other repos when they create a production tag
  repository_dispatch:
    types: [release-ready]
  
  # Manual trigger with UI form
  workflow_dispatch:
    inputs:
      release_name:
        description: 'Release name (e.g., Weekly Release, Hotfix). Leave empty to use today''s date (ddmmyyyy)'
        required: false
        default: ''
      repos:
        description: 'Repos to include (comma-separated, or "all")'
        required: false
        default: 'all'
      dry_run:
        description: 'Dry run - only show PRs, do not post anywhere'
        type: boolean
        required: false
        default: true

env:
  CONFLUENCE_BASE_URL: https://boompay.atlassian.net/wiki
  CONFLUENCE_SPACE_KEY: RN
  JIRA_BASE_URL: https://boompay.atlassian.net/browse
  
  # List of all repositories to check
  # âš ï¸ UPDATE THESE WITH YOUR ACTUAL REPO NAMES (owner will be auto-detected)
  ALL_REPOS: |
    hack-repo1
    hack-repo2

jobs:
  generate-release-notes:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: "ðŸ” DEBUG: Show trigger info"
        run: |
          echo "## Trigger Information" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Event name | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dry run | ${{ github.event.inputs.dry_run }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Input repos | ${{ github.event.inputs.repos }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dispatch repo | ${{ github.event.client_payload.repo }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dispatch tag | ${{ github.event.client_payload.tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Determine which repos to process
        id: repos
        run: |
          echo "## Repos to Process" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            # Single repo triggered this
            echo "repos=${{ github.event.client_payload.repo }}" >> $GITHUB_OUTPUT
            echo "triggered_by=tag" >> $GITHUB_OUTPUT
            echo "tag=${{ github.event.client_payload.tag }}" >> $GITHUB_OUTPUT
            echo "Triggered by tag from: ${{ github.event.client_payload.repo }}" >> $GITHUB_STEP_SUMMARY
          else
            # Manual trigger
            INPUT_REPOS="${{ github.event.inputs.repos }}"
            if [[ "$INPUT_REPOS" == "all" || -z "$INPUT_REPOS" ]]; then
              # Use all repos (remove newlines)
              REPOS=$(echo "$ALL_REPOS" | tr '\n' ',' | sed 's/,$//' | sed 's/^,//')
              echo "repos=$REPOS" >> $GITHUB_OUTPUT
              echo "Using ALL_REPOS: $REPOS" >> $GITHUB_STEP_SUMMARY
            else
              echo "repos=$INPUT_REPOS" >> $GITHUB_OUTPUT
              echo "Using input repos: $INPUT_REPOS" >> $GITHUB_STEP_SUMMARY
            fi
            echo "triggered_by=manual" >> $GITHUB_OUTPUT
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: "ðŸ” DEBUG: Show repos being checked"
        run: |
          echo "### Repositories to check:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.repos.outputs.repos }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Determine release name
        id: release_name
        run: |
          INPUT_RELEASE_NAME="${{ github.event.inputs.release_name }}"
          
          if [[ -n "$INPUT_RELEASE_NAME" ]]; then
            # Use the provided release name
            RELEASE_NAME="$INPUT_RELEASE_NAME"
            echo "Using provided release name: $RELEASE_NAME" >> $GITHUB_STEP_SUMMARY
          else
            # Default to today's date in ddmmyyyy format
            RELEASE_NAME=$(date +%d%m%Y)
            echo "Using default release name (today's date): $RELEASE_NAME" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Collect PRs from all repositories
        id: collect
        uses: actions/github-script@v7
        env:
          REPOS_TO_CHECK: ${{ steps.repos.outputs.repos }}
        with:
          github-token: ${{ secrets.REPO_ACCESS_TOKEN }}
          script: |
            const repos = process.env.REPOS_TO_CHECK.split(',').map(r => r.trim()).filter(r => r);
            const allPRs = {};
            const debugInfo = [];
            
            console.log('='.repeat(50));
            console.log('REPOS TO CHECK:', repos);
            console.log('='.repeat(50));
            
            // Get default owner from GitHub context
            const defaultOwner = context.repo.owner;
            
            for (const repoFullName of repos) {
              let owner, repo;
              
              // Check if repo includes owner (format: owner/repo) or just repo name
              if (repoFullName.includes('/')) {
                [owner, repo] = repoFullName.split('/');
              } else {
                // Just repo name provided, use default owner
                owner = defaultOwner;
                repo = repoFullName;
              }
              
              if (!owner || !repo) {
                console.log(`âŒ Invalid repo format: ${repoFullName}`);
                debugInfo.push(`âŒ Invalid repo format: ${repoFullName}`);
                continue;
              }
              
              console.log(`\nðŸ“¦ Checking ${owner}/${repo}...`);
              debugInfo.push(`\n### ${owner}/${repo}`);
              
              try {
                // Get merged PRs from both master and main branches
                let allPRsData = [];
                
                for (const baseBranch of ['master', 'main']) {
                  try {
                    const prs = await github.rest.pulls.list({
                      owner,
                      repo,
                      state: 'closed',
                      base: baseBranch,
                      per_page: 100,
                      sort: 'updated',
                      direction: 'desc'
                    });
                    console.log(`  ðŸ“ Found ${prs.data.length} closed PRs to ${baseBranch}`);
                    debugInfo.push(`- Closed PRs to ${baseBranch}: ${prs.data.length}`);
                    allPRsData = allPRsData.concat(prs.data);
                  } catch (branchError) {
                    console.log(`  â„¹ï¸ Branch '${baseBranch}' not found or no PRs`);
                  }
                }
                
                // Deduplicate PRs (in case a PR somehow appears in both)
                const seenPRs = new Set();
                const prsData = allPRsData.filter(pr => {
                  if (seenPRs.has(pr.number)) return false;
                  seenPRs.add(pr.number);
                  return true;
                });
                
                console.log(`  ðŸ“ Total unique closed PRs found: ${prsData.length}`);
                debugInfo.push(`- Total unique closed PRs: ${prsData.length}`);
                
                // For monorepo hack-repo1, we'll group PRs by the checked option in PR body
                const releasePRsBySubrepo = {};
                let mergedCount = 0;
                let withLabelCount = 0;
                
                // Calculate 48 hours ago timestamp
                const now = new Date();
                const fortyEightHoursAgo = new Date(now.getTime() - (48 * 60 * 60 * 1000));
                
                // Helper function to extract checked repo name from PR body for hack-repo1
                const extractRepoNameFromPRBody = (prBody) => {
                  if (!prBody) return null;
                  
                  const allCheckboxes = [];
                  const checkedOptions = [];
                  
                  // Find all checkbox lines (both checked and unchecked)
                  const lines = prBody.split('\n');
                  for (const line of lines) {
                    const trimmedLine = line.trim();
                    // Match checkbox pattern: - [x] NAME or - [ x ] NAME or - [ ] NAME
                    // This matches both checked [x] and unchecked [ ] boxes
                    const checkboxMatch = trimmedLine.match(/^-\s*\[\s*([x\s]*)\]\s*(.+)$/i);
                    if (checkboxMatch) {
                      const isChecked = checkboxMatch[1].toLowerCase().includes('x');
                      const optionText = checkboxMatch[2].trim();
                      
                      // Extract the repo name (first word, typically uppercase like AX, PX, SDK, CRM)
                      const repoNameMatch = optionText.match(/^([A-Z]+)/);
                      if (repoNameMatch) {
                        const repoName = repoNameMatch[1];
                        const hasTag = optionText.length > repoNameMatch[1].length; // Has additional text after repo name
                        
                        allCheckboxes.push({
                          repoName: repoName,
                          fullText: optionText,
                          hasTag: hasTag,
                          isChecked: isChecked
                        });
                        
                        if (isChecked) {
                          checkedOptions.push({
                            repoName: repoName,
                            fullText: optionText,
                            hasTag: hasTag
                          });
                        }
                      }
                    }
                  }
                  
                  if (checkedOptions.length === 0) return null;
                  
                  // Check if ANY option (checked or unchecked) has a tag
                  const hasAnyTag = allCheckboxes.some(cb => cb.hasTag);
                  
                  if (hasAnyTag) {
                    // If any option has a tag, use default name
                    return 'hack-repo1';
                  }
                  
                  // Return the first checked repo name
                  return checkedOptions[0].repoName;
                };
                
                for (const pr of prsData) {
                  const isMerged = !!pr.merged_at;
                  const labels = pr.labels.map(l => l.name.toLowerCase());
                  const hasReleaseLabel = labels.includes('release') || labels.includes('release_if_approved');
                  
                  // Check if PR was merged in the last 48 hours
                  let mergedInLast48Hours = false;
                  if (isMerged && pr.merged_at) {
                    const mergedAt = new Date(pr.merged_at);
                    mergedInLast48Hours = mergedAt >= fortyEightHoursAgo;
                  }
                  
                  if (isMerged) mergedCount++;
                  if (hasReleaseLabel) withLabelCount++;
                  
                  // Log all PRs for debugging
                  console.log(`    PR#${pr.number}: "${pr.title.substring(0, 50)}..." | merged: ${isMerged} | merged_in_48h: ${mergedInLast48Hours} | labels: [${labels.join(', ')}]`);
                  
                  if (hasReleaseLabel && isMerged && mergedInLast48Hours) {
                    // Extract JIRA ticket from PR body
                    const jiraPattern = /https:\/\/boompay\.atlassian\.net\/browse\/([A-Z]+-\d+)/g;
                    const bodyMatches = pr.body ? [...pr.body.matchAll(jiraPattern)] : [];
                    
                    // Also check PR title for ticket ID
                    const titlePattern = /([A-Z]+-\d+)/;
                    const titleMatch = pr.title.match(titlePattern);
                    
                    let ticketId = '';
                    if (bodyMatches.length > 0) {
                      ticketId = bodyMatches[0][1];
                    } else if (titleMatch) {
                      ticketId = titleMatch[1];
                    }
                    
                    const prData = {
                      number: pr.number,
                      title: pr.title,
                      author: pr.user.login,
                      ticketId: ticketId,
                      mergedAt: pr.merged_at,
                      url: pr.html_url
                    };
                    
                    // For hack-repo1, extract repo name from PR body
                    let targetRepoKey = repo;
                    if (repo === 'hack-repo1') {
                      const extractedRepoName = extractRepoNameFromPRBody(pr.body);
                      if (extractedRepoName) {
                        targetRepoKey = extractedRepoName;
                        console.log(`    ðŸ“ PR#${pr.number}: Extracted repo name "${extractedRepoName}" from PR body`);
                      } else {
                        // If no checkbox found, use default
                        targetRepoKey = 'hack-repo1';
                        console.log(`    âš ï¸ PR#${pr.number}: No checkbox found in PR body, using default "hack-repo1"`);
                      }
                    }
                    
                    // Initialize array for this repo key if it doesn't exist
                    if (!releasePRsBySubrepo[targetRepoKey]) {
                      releasePRsBySubrepo[targetRepoKey] = [];
                    }
                    
                    releasePRsBySubrepo[targetRepoKey].push(prData);
                    
                    console.log(`    âœ… INCLUDED: PR#${pr.number} - ${pr.title.substring(0, 40)}... (grouped under: ${targetRepoKey})`);
                  }
                }
                
                console.log(`  ðŸ“Š Summary: ${mergedCount} merged, ${withLabelCount} with 'release'/'release_if_approved' label`);
                debugInfo.push(`- Merged PRs: ${mergedCount}`);
                debugInfo.push(`- PRs with 'release' or 'release_if_approved' label: ${withLabelCount}`);
                
                // Add all grouped PRs to allPRs
                let totalPRs = 0;
                for (const [repoKey, prs] of Object.entries(releasePRsBySubrepo)) {
                  if (prs.length > 0) {
                    // If repoKey already exists (from another iteration), merge arrays
                    if (allPRs[repoKey]) {
                      allPRs[repoKey] = allPRs[repoKey].concat(prs);
                    } else {
                      allPRs[repoKey] = prs;
                    }
                    totalPRs += prs.length;
                    debugInfo.push(`- âœ… Added ${prs.length} PRs to release notes under "${repoKey}"`);
                  }
                }
                
                if (totalPRs === 0) {
                  debugInfo.push(`- âš ï¸ No PRs matched criteria`);
                }
                
              } catch (error) {
                console.error(`âŒ Error fetching PRs from ${repoFullName}: ${error.message}`);
                debugInfo.push(`- âŒ ERROR: ${error.message}`);
              }
            }
            
            console.log('\n' + '='.repeat(50));
            console.log('FINAL RESULT:', JSON.stringify(allPRs, null, 2));
            console.log('='.repeat(50));
            
            // Set debug info as output for summary
            core.setOutput('debug_info', debugInfo.join('\n'));
            
            return allPRs;

      - name: "ðŸ” DEBUG: Show collected PRs"
        run: |
          echo "## PR Collection Results" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.collect.outputs.debug_info }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Raw PR Data (JSON)" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          echo '${{ steps.collect.outputs.result }}' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Format release notes
        id: format
        uses: actions/github-script@v7
        env:
          PR_DATA: ${{ steps.collect.outputs.result }}
          JIRA_BASE: ${{ env.JIRA_BASE_URL }}
          RELEASE_NAME: ${{ steps.release_name.outputs.release_name }}
        with:
          script: |
            const prData = JSON.parse(process.env.PR_DATA);
            const jiraBase = process.env.JIRA_BASE;
            const releaseName = process.env.RELEASE_NAME;
            
            // Repository name aliases mapping
            const repoAliases = {
              'hack-repo1': 'PX',
              'hack-repo2': 'AX'
            };
            
            // Helper function to get display name (alias or original)
            const getDisplayName = (repo) => repoAliases[repo] || repo;
            
            console.log('PR Data received:', JSON.stringify(prData, null, 2));
            console.log('Number of repos with PRs:', Object.keys(prData).length);
            console.log('Release name:', releaseName);
            
            // Check if we have any PRs
            const hasPRs = Object.keys(prData).length > 0;
            
            // Initialize messages
            let slackMessage = '';
            let confluenceHtml = '';
            let plainText = '';
            
            if (hasPRs) {
              // Add header only once at the beginning if there are PRs
              slackMessage = `*ðŸš€ Release Notes - ${releaseName}*\n\n`;
              confluenceHtml = `<h1>Release Notes - ${releaseName}</h1>`;
              plainText = `Release Notes - ${releaseName}\n${'='.repeat(40)}\n\n`;
              
              // Loop through repos and add their PRs
              for (const [repo, prs] of Object.entries(prData)) {
                const displayName = getDisplayName(repo);
                slackMessage += `*${displayName}*\n`;
                confluenceHtml += `<h2>${displayName}</h2><ul>`;
                plainText += `${displayName}\n${'-'.repeat(displayName.length)}\n`;
                
                for (const pr of prs) {
                  const ticketLink = pr.ticketId ? `${jiraBase}/${pr.ticketId}` : '';
                  const ticketDisplay = pr.ticketId || 'No ticket';
                  
                  // Slack format
                  if (pr.ticketId) {
                    slackMessage += `  â€¢ <${ticketLink}|${pr.ticketId}> - ${pr.title} - <${pr.url}|PR#${pr.number}> By: @${pr.author}\n`;
                  } else {
                    slackMessage += `  â€¢ ${ticketDisplay} - ${pr.title} - <${pr.url}|PR#${pr.number}> By: @${pr.author}\n`;
                  }
                  
                  // Confluence HTML
                  if (pr.ticketId) {
                    confluenceHtml += `<li><a href="${ticketLink}">${pr.ticketId}</a> - ${pr.title} - <a href="${pr.url}">PR#${pr.number}</a> By: @${pr.author}</li>`;
                  } else {
                    confluenceHtml += `<li>${ticketDisplay} - ${pr.title} - <a href="${pr.url}">PR#${pr.number}</a> By: @${pr.author}</li>`;
                  }
                  
                  // Plain text
                  plainText += `  â€¢ ${ticketDisplay} - ${pr.title} - PR#${pr.number} By: @${pr.author}\n`;
                }
                
                slackMessage += '\n';
                confluenceHtml += '</ul>';
                plainText += '\n';
              }
            } else {
              // No PRs found
              slackMessage = `*ðŸš€ Release Notes - ${releaseName}*\n\nNo PRs with 'release' or 'release_if_approved' label found (merged in last 48 hours).`;
              confluenceHtml = `<h1>Release Notes - ${releaseName}</h1><p>No PRs with 'release' or 'release_if_approved' label found (merged in last 48 hours).</p>`;
              plainText = `Release Notes - ${releaseName}\n\nNo PRs with 'release' or 'release_if_approved' label found (merged in last 48 hours).`;
            }
            
            console.log('Has PRs:', hasPRs);
            console.log('Plain text output:\n', plainText);
            
            core.setOutput('slack_message', slackMessage);
            core.setOutput('confluence_html', confluenceHtml);
            core.setOutput('plain_text', plainText);
            core.setOutput('date_title', releaseName);
            core.setOutput('has_prs', hasPRs.toString());

      - name: "ðŸ“‹ PREVIEW: Release Notes"
        run: |
          echo "## ðŸ“‹ Release Notes Preview" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Plain Text Format" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ${{ steps.format.outputs.plain_text }}
          EOF
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Has PRs: ${{ steps.format.outputs.has_prs }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: "ðŸ“‹ Copy-Paste Ready Format (for manual Confluence posting)"
        if: steps.format.outputs.has_prs == 'true'
        uses: actions/github-script@v7
        env:
          PR_DATA: ${{ steps.collect.outputs.result }}
          JIRA_BASE: ${{ env.JIRA_BASE_URL }}
          RELEASE_NAME: ${{ steps.release_name.outputs.release_name }}
        with:
          script: |
            const prData = JSON.parse(process.env.PR_DATA);
            const jiraBase = process.env.JIRA_BASE;
            const releaseName = process.env.RELEASE_NAME;
            
            // Repository name aliases mapping
            const repoAliases = {
              'hack-repo1': 'PX',
              'hack-repo2': 'AX'
            };
            
            // Helper function to get display name (alias or original)
            const getDisplayName = (repo) => repoAliases[repo] || repo;
            
            let markdown = `# Release Notes - ${releaseName}\n\n`;
            
            for (const [repo, prs] of Object.entries(prData)) {
              const displayName = getDisplayName(repo);
              markdown += `## ${displayName}\n\n`;
              
              for (const pr of prs) {
                const ticketLink = pr.ticketId ? `${jiraBase}/${pr.ticketId}` : '';
                const ticketDisplay = pr.ticketId || 'No ticket';
                
                if (pr.ticketId) {
                  markdown += `- [${pr.ticketId}](${ticketLink}) - ${pr.title} - [PR#${pr.number}](${pr.url}) By: @${pr.author}\n`;
                } else {
                  markdown += `- ${ticketDisplay} - ${pr.title} - [PR#${pr.number}](${pr.url}) By: @${pr.author}\n`;
                }
              }
              
              markdown += '\n';
            }
            
            // Output to step summary for easy copy-paste
            const fs = require('fs');
            const summaryPath = process.env.GITHUB_STEP_SUMMARY;
            
            fs.appendFileSync(summaryPath, '## ðŸ“‹ Copy-Paste Ready Format\n\n');
            fs.appendFileSync(summaryPath, '**Use this if Confluence push fails - copy the content below:**\n\n');
            fs.appendFileSync(summaryPath, '<details>\n<summary>Click to expand and copy</summary>\n\n');
            fs.appendFileSync(summaryPath, '```markdown\n');
            fs.appendFileSync(summaryPath, markdown);
            fs.appendFileSync(summaryPath, '\n```\n\n');
            fs.appendFileSync(summaryPath, '</details>\n\n');
            
            // Also output as a code block for easy selection
            fs.appendFileSync(summaryPath, '### Formatted Text (ready for Confluence):\n\n');
            fs.appendFileSync(summaryPath, '<pre style="background: #f4f4f4; padding: 10px; border-radius: 5px; overflow-x: auto;">\n');
            fs.appendFileSync(summaryPath, markdown.replace(/</g, '&lt;').replace(/>/g, '&gt;'));
            fs.appendFileSync(summaryPath, '\n</pre>\n\n');

      - name: "ðŸš« DRY RUN: Skip posting"
        if: github.event.inputs.dry_run == 'true'
        run: |
          echo "## âš ï¸ DRY RUN MODE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Skipping Slack and Confluence posting because dry_run is enabled." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To actually post, run the workflow again with 'Dry run' unchecked." >> $GITHUB_STEP_SUMMARY

      - name: Create Confluence page
        if: steps.format.outputs.has_prs == 'true' && github.event.inputs.dry_run != 'true'
        id: confluence
        continue-on-error: true
        run: |
          RELEASE_NAME="${{ steps.release_name.outputs.release_name }}"
          CONTENT=$(echo '${{ steps.format.outputs.confluence_html }}' | jq -Rs .)
          
          echo "ðŸ” DEBUG: Creating Confluence page..." >> $GITHUB_STEP_SUMMARY
          echo "Title: Release Notes - ${RELEASE_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "Space: ${{ env.CONFLUENCE_SPACE_KEY }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Build JSON payload (without ancestors - creating top-level page)
          JSON_PAYLOAD=$(jq -n \
            --arg type "page" \
            --arg title "${RELEASE_NAME}" \
            --arg space_key "${{ env.CONFLUENCE_SPACE_KEY }}" \
            --argjson content "${CONTENT}" \
            '{
              "type": $type,
              "title": $title,
              "space": {"key": $space_key},
              "body": {
                "storage": {
                  "value": $content,
                  "representation": "storage"
                }
              }
            }')
          
          echo "ðŸ“¤ Sending request to Confluence..." >> $GITHUB_STEP_SUMMARY
          
          # Make the API call with error handling
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "${{ env.CONFLUENCE_BASE_URL }}/rest/api/content" \
            -H "Authorization: Basic ${{ secrets.CONFLUENCE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "${JSON_PAYLOAD}")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo "HTTP Status Code: ${HTTP_CODE}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${HTTP_CODE}" -ge 200 ] && [ "${HTTP_CODE}" -lt 300 ]; then
            echo "âœ… Successfully created Confluence page!" >> $GITHUB_STEP_SUMMARY
            PAGE_RELATIVE_URL=$(echo "$RESPONSE_BODY" | jq -r '._links.webui // empty')
            if [ -n "$PAGE_RELATIVE_URL" ]; then
              # Construct full URL
              FULL_PAGE_URL="${{ env.CONFLUENCE_BASE_URL }}$PAGE_RELATIVE_URL"
              echo "Page URL: ${FULL_PAGE_URL}" >> $GITHUB_STEP_SUMMARY
              echo "page_url=${FULL_PAGE_URL}" >> $GITHUB_OUTPUT
              echo "success=true" >> $GITHUB_OUTPUT
            else
              echo "âš ï¸ Warning: Could not extract page URL from response" >> $GITHUB_STEP_SUMMARY
              echo "page_url=" >> $GITHUB_OUTPUT
              echo "success=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âŒ Failed to create Confluence page" >> $GITHUB_STEP_SUMMARY
            echo "âš ï¸ **Workflow will continue - Slack will still be posted**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Response body:" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            echo "$RESPONSE_BODY" | jq '.' >> $GITHUB_STEP_SUMMARY 2>&1 || echo "$RESPONSE_BODY" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Common issues:" >> $GITHUB_STEP_SUMMARY
            echo "- Check that CONFLUENCE_API_TOKEN is base64 encoded email:token" >> $GITHUB_STEP_SUMMARY
            echo "- Check that the space key is correct" >> $GITHUB_STEP_SUMMARY
            echo "- Verify you have permission to create pages in this space" >> $GITHUB_STEP_SUMMARY
            echo "page_url=" >> $GITHUB_OUTPUT
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      - name: Update Slack message with Confluence link
        if: steps.format.outputs.has_prs == 'true' && github.event.inputs.dry_run != 'true'
        id: update_slack
        run: |
          ORIGINAL_MESSAGE='${{ steps.format.outputs.slack_message }}'
          CONFLUENCE_URL="${{ steps.confluence.outputs.page_url }}"
          CONFLUENCE_SUCCESS="${{ steps.confluence.outputs.success }}"
          RELEASE_NAME="${{ steps.release_name.outputs.release_name }}"
          
          # Check if Confluence was successful and URL is available
          if [ -n "$CONFLUENCE_URL" ] && [ "$CONFLUENCE_SUCCESS" == "true" ]; then
            # Replace the release name in the title with a hyperlinked version
            # Use # as sed delimiter to avoid conflicts with | in Slack link format
            UPDATED_MESSAGE=$(echo "$ORIGINAL_MESSAGE" | sed "s#\*ðŸš€ Release Notes - ${RELEASE_NAME}\*#*ðŸš€ Release Notes - <${CONFLUENCE_URL}|${RELEASE_NAME}>*#")
            echo "slack_message<<EOF" >> $GITHUB_OUTPUT
            echo "$UPDATED_MESSAGE" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "âœ… Updated Slack message with Confluence link" >> $GITHUB_STEP_SUMMARY
            echo "Confluence URL: ${CONFLUENCE_URL}" >> $GITHUB_STEP_SUMMARY
          else
            # No Confluence URL or Confluence failed, use original message
            echo "slack_message<<EOF" >> $GITHUB_OUTPUT
            echo "$ORIGINAL_MESSAGE" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            if [ "$CONFLUENCE_SUCCESS" == "false" ]; then
              echo "âš ï¸ Confluence page creation failed - Slack will be posted without Confluence link" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ’¡ Check the 'Copy-Paste Ready Format' section above to manually create the Confluence page" >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ No Confluence URL available, using original message" >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Post to Slack
        if: steps.format.outputs.has_prs == 'true' && github.event.inputs.dry_run != 'true'
        uses: slackapi/slack-github-action@v1.26.0
        with:
          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}
          slack-message: ${{ steps.update_slack.outputs.slack_message }}
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

      - name: "ðŸ” DEBUG: Check conditions before label removal"
        run: |
          echo "## ðŸ” Label Removal Conditions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Condition | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| has_prs | ${{ steps.format.outputs.has_prs }} |" >> $GITHUB_STEP_SUMMARY
          echo "| dry_run input | ${{ github.event.inputs.dry_run }} |" >> $GITHUB_STEP_SUMMARY
          echo "| dry_run != true | ${{ github.event.inputs.dry_run != 'true' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Should run? | ${{ steps.format.outputs.has_prs == 'true' && github.event.inputs.dry_run != 'true' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Remove release labels from processed PRs
        if: steps.format.outputs.has_prs == 'true' && github.event.inputs.dry_run != 'true'
        id: remove_labels
        uses: actions/github-script@v7
        env:
          PR_DATA: ${{ steps.collect.outputs.result }}
          REPOS_TO_CHECK: ${{ steps.repos.outputs.repos }}
        with:
          github-token: ${{ secrets.REPO_ACCESS_TOKEN }}
          script: |
            const prData = JSON.parse(process.env.PR_DATA);
            const reposToCheck = process.env.REPOS_TO_CHECK.split(',').map(r => r.trim()).filter(r => r);
            
            console.log('='.repeat(50));
            console.log('REMOVE LABELS - DEBUG INFO');
            console.log('='.repeat(50));
            console.log('PR Data:', JSON.stringify(prData, null, 2));
            console.log('Repos to check:', reposToCheck);
            
            // Build a map of repo name -> owner
            const defaultOwner = context.repo.owner;
            const repoOwnerMap = {};
            for (const repoFullName of reposToCheck) {
              let owner, repo;
              
              // Check if repo includes owner (format: owner/repo) or just repo name
              if (repoFullName.includes('/')) {
                [owner, repo] = repoFullName.split('/');
              } else {
                // Just repo name provided, use default owner
                owner = defaultOwner;
                repo = repoFullName;
              }
              
              if (owner && repo) {
                repoOwnerMap[repo] = owner;
              }
            }
            
            console.log('Repo owner map:', JSON.stringify(repoOwnerMap, null, 2));
            
            const results = [];
            
            if (Object.keys(prData).length === 0) {
              console.log('âš ï¸ No PRs in prData!');
              results.push('âš ï¸ No PRs to process');
            }
            
            for (const [repo, prs] of Object.entries(prData)) {
              const owner = repoOwnerMap[repo];
              
              if (!owner) {
                console.log(`âŒ Could not find owner for repo: ${repo}`);
                results.push(`âŒ ${repo}: owner not found in map`);
                continue;
              }
              
              console.log(`\nðŸ“¦ Removing labels from ${owner}/${repo}...`);
              results.push(`\nðŸ“¦ ${owner}/${repo}:`);
              
              for (const pr of prs) {
                console.log(`  Attempting to remove labels from PR#${pr.number}...`);
                console.log(`    URL: https://github.com/${owner}/${repo}/pull/${pr.number}`);
                
                const labelsToRemove = ['release', 'release_if_approved'];
                let removedLabels = [];
                
                for (const labelName of labelsToRemove) {
                  try {
                    const response = await github.rest.issues.removeLabel({
                      owner,
                      repo,
                      issue_number: pr.number,
                      name: labelName
                    });
                    console.log(`  âœ… Removed '${labelName}' label. Status: ${response.status}`);
                    removedLabels.push(labelName);
                  } catch (error) {
                    // Label might not exist, which is fine
                    if (error.status === 404) {
                      console.log(`  â„¹ï¸ Label '${labelName}' not found (may have been removed already)`);
                    } else {
                      console.log(`  âš ï¸ Failed to remove '${labelName}': ${error.message}`);
                    }
                  }
                }
                
                if (removedLabels.length > 0) {
                  results.push(`  âœ… PR#${pr.number}: removed labels [${removedLabels.join(', ')}]`);
                } else {
                  results.push(`  â„¹ï¸ PR#${pr.number}: no labels to remove`);
                }
              }
            }
            
            const finalResults = results.length > 0 ? results.join('\n') : 'âš ï¸ No results generated';
            console.log('Final results:', finalResults);
            core.setOutput('results', finalResults);

      - name: "ðŸ·ï¸ Label Removal Results"
        if: always()
        run: |
          echo "## ðŸ·ï¸ Label Removal Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ -z "${{ steps.remove_labels.outputs.results }}" ]]; then
            echo "âš ï¸ **Step was skipped or produced no output**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Possible reasons:" >> $GITHUB_STEP_SUMMARY
            echo "- Dry run is enabled" >> $GITHUB_STEP_SUMMARY
            echo "- No PRs with 'release' or 'release_if_approved' label found (merged in last 48h)" >> $GITHUB_STEP_SUMMARY
            echo "- Step conditions not met" >> $GITHUB_STEP_SUMMARY
          else
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.remove_labels.outputs.results }}" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: "âœ… Summary"
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "## âœ… Workflow Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Action | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|--------|" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
            echo "| Slack | â­ï¸ Skipped (dry run) |" >> $GITHUB_STEP_SUMMARY
            echo "| Confluence | â­ï¸ Skipped (dry run) |" >> $GITHUB_STEP_SUMMARY
            echo "| Remove labels | â­ï¸ Skipped (dry run) |" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ steps.format.outputs.has_prs }}" == "true" ]]; then
            echo "| Slack | âœ… Posted |" >> $GITHUB_STEP_SUMMARY
            CONFLUENCE_SUCCESS="${{ steps.confluence.outputs.success }}"
            if [[ "$CONFLUENCE_SUCCESS" == "true" ]]; then
              echo "| Confluence | âœ… Created |" >> $GITHUB_STEP_SUMMARY
            elif [[ -n "${{ steps.confluence.outputs.page_url }}" ]]; then
              echo "| Confluence | âš ï¸ Created (URL extraction failed) |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Confluence | âŒ Failed (see copy-paste format above) |" >> $GITHUB_STEP_SUMMARY
            fi
            echo "| Remove labels | âœ… Done |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Slack | â­ï¸ Skipped (no PRs) |" >> $GITHUB_STEP_SUMMARY
            echo "| Confluence | â­ï¸ Skipped (no PRs) |" >> $GITHUB_STEP_SUMMARY
            echo "| Remove labels | â­ï¸ Skipped (no PRs) |" >> $GITHUB_STEP_SUMMARY
          fi
